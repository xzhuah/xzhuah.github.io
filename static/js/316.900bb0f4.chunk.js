"use strict";(self.webpackChunkmy_dimension_client=self.webpackChunkmy_dimension_client||[]).push([[316],{87316:(e,n,i)=>{i.r(n),i.d(n,{mmdOutlineVertexShader:()=>o});i(22361),i(96045),i(97577),i(86736),i(38706),i(17748),i(48455),i(11289),i(4614),i(91632),i(15139),i(5445),i(25236),i(53957);const t="mmdOutlineVertexShader",r="\nattribute position: vec3f;attribute normal: vec3f;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\nuniform offset: f32;\n#include<instancesDeclaration>\nuniform viewport: vec2f;uniform view: mat3x3f;uniform viewProjection: mat4x4f;\n#ifdef WORLDPOS_REQUIRED\nuniform inverseViewProjection: mat4x4f;\n#endif\n#ifdef ALPHATEST\nvarying vUV: vec2f;uniform diffuseMatrix: mat4x4f; \n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input: VertexInputs)->FragmentInputs {var positionUpdated: vec3f=vertexInputs.position;var normalUpdated: vec3f=vertexInputs.normal;\n#ifdef UV1\nvar uvUpdated: vec2f=vertexInputs.uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar viewNormal: vec3f=uniforms.view*(mat3x3(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz)*normalUpdated);var projectedPosition: vec4f=uniforms.viewProjection*finalWorld*vec4f(positionUpdated,1.0);var screenNormal: vec2f=normalize(viewNormal.xy);projectedPosition=vec4f(\nprojectedPosition.xy+(screenNormal/(uniforms.viewport*0.25/*0.5 */)*uniforms.offset*projectedPosition.w),\nprojectedPosition.z,\nprojectedPosition.w\n);vertexOutputs.position=projectedPosition;\n#ifdef WORLDPOS_REQUIRED\nvar worldPos: vec4f=uniforms.inverseViewProjection*projectedPosition;\n#endif\n#ifdef ALPHATEST\n#ifdef UV1\nvertexOutputs.vUV=(uniforms.diffuseMatrix*vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef UV2\nvertexOutputs.vUV=(uniforms.diffuseMatrix*vec4f(vertexInputs.uv2,1.0,0.0)).xy;\n#endif\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n}\n";i(44453).l.ShadersStoreWGSL[t]=r;const o={name:t,shader:r}}}]);
//# sourceMappingURL=316.900bb0f4.chunk.js.map