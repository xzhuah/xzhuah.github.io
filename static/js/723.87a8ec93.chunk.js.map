{"version":3,"file":"static/js/723.87a8ec93.chunk.js","mappings":"4NAKO,MAAMA,UAA0BC,EAAAA,GAMnCC,YAAAA,CAAaC,GACT,OAAQA,IACCC,EAAAA,EAAeC,IAK5B,CACAC,aAAAA,CAAcC,GACV,GAAmB,WAAfA,EAAyB,CACzB,MAAMC,EAAQ,CAAC,EAGf,OAFAA,EAAiC,0BAAIC,EAAAA,EACrCD,EAAM,KAAIE,EAAAA,EAAAA,GAAa,uCAAoD,KAAKC,EAAAA,0CACzEH,CACX,CACA,GAAmB,aAAfD,EAA2B,CAC3B,MAAMC,EAAQ,CACdA,4BAAkD,oOAClDA,2BAAiD,wDACjDA,EAAM,KAAIE,EAAAA,EAAAA,GAAa,0DAAuE,2NAC9FF,EAAM,KAAIE,EAAAA,EAAAA,GAAa,+CAA4D,2IACnFF,EAAM,KAAIE,EAAAA,EAAAA,GAAa,wGAAqH,wlBAC5IF,EAAM,KAAIE,EAAAA,EAAAA,GAAa,6BAA0C,yGAEjEF,EAAM,KAAIE,EAAAA,EAAAA,GAAa,mDAAgE,wQACvFF,EAAM,KAAIE,EAAAA,EAAAA,GAAa,wCAAqD,m0BAC5E,MAAME,EAA0B,+dAGhC,OAFAJ,EAAM,KAAIE,EAAAA,EAAAA,GAAaE,MAA8B,wcAAwcA,EAAaC,QAAQ,cAAe,2BACjiBL,EAAkC,2BAAe,4jCAC1CA,CACX,CACA,OAAO,IACX,E,iBCtCG,SAASE,EAAaI,GACzB,OAAOA,EAAID,QAAQ,sBAAuB,OAC9C,C","sources":["../node_modules/babylon-mmd/esm/Loader/ShadersWGSL/mmdStandard.js","../node_modules/babylon-mmd/esm/Loader/Util/escapeRegExp.js"],"sourcesContent":["import { ShaderLanguage } from \"@babylonjs/core/Materials/shaderLanguage\";\nimport { MmdPluginMaterial as MmdPluginMaterialBase } from \"../mmdPluginMaterial\";\nimport { escapeRegExp } from \"../Util/escapeRegExp\";\nimport { sdefDeclaration } from \"./sdefDeclaration\";\nimport { sdefVertex } from \"./sdefVertex\";\nexport class MmdPluginMaterial extends MmdPluginMaterialBase {\n    /**\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\n     * @param shaderLanguage The shader language to use.\n     * @returns true if the plugin is compatible with the shader language\n     */\n    isCompatible(shaderLanguage) {\n        switch (shaderLanguage) {\n            case ShaderLanguage.WGSL:\n                return true;\n            default:\n                return false;\n        }\n    }\n    getCustomCode(shaderType) {\n        if (shaderType === \"vertex\") {\n            const codes = {};\n            codes[\"CUSTOM_VERTEX_DEFINITIONS\"] = sdefDeclaration;\n            codes[`!${escapeRegExp(\"finalWorld=finalWorld*influence;\")}`] = /* wgsl */ `\\n${sdefVertex}\\nfinalWorld=(finalWorld*influence);\\n`;\n            return codes;\n        }\n        if (shaderType === \"fragment\") {\n            const codes = {};\n            codes[\"CUSTOM_FRAGMENT_DEFINITIONS\"] = /* wgsl */ \"\\n#if defined(SPHERE_TEXTURE) && defined(NORMAL)\\nvar sphereSamplerSampler: sampler;var sphereSampler: texture_2d<f32>;\\n#endif\\n#ifdef TOON_TEXTURE\\nvar toonSamplerSampler: sampler;var toonSampler: texture_2d<f32>;\\n#endif\\n\";\n            codes[\"CUSTOM_FRAGMENT_MAIN_BEGIN\"] = /* wgsl */ \"\\n#ifdef TOON_TEXTURE\\nvar toonNdl: vec3f;\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"var diffuseColor: vec3f=uniforms.vDiffuseColor.rgb;\")}`] = /* wgsl */ \"\\n#ifdef APPLY_AMBIENT_COLOR_TO_DIFFUSE\\nvar diffuseColor: vec3f=clamp(uniforms.vDiffuseColor.rgb+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0));\\n#else\\nvar diffuseColor: vec3f=(uniforms.vDiffuseColor.rgb);\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"var alpha: f32=uniforms.vDiffuseColor.a;\")}`] = /* wgsl */ \"\\n#ifdef CLAMP_ALPHA\\nvar alpha: f32=clamp(uniforms.vDiffuseColor.a,0.0,1.0);\\n#else\\nvar alpha: f32=uniforms.vDiffuseColor.a;\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"baseColor=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vDiffuseUV+uvOffset);\")}`] = /* wgsl */ \"\\n#if defined(DIFFUSE) && defined(TEXTURE_COLOR)\\nbaseColor=textureSample(diffuseSampler,diffuseSamplerSampler,(fragmentInputs.vDiffuseUV+uvOffset));baseColor=vec4f(\\nmix(\\nvec3f(1.0),\\nbaseColor.rgb*uniforms.textureMultiplicativeColor.rgb,\\nuniforms.textureMultiplicativeColor.a\\n),\\nbaseColor.a\\n);baseColor=vec4f(\\nclamp(\\nbaseColor.rgb+(baseColor.rgb-vec3f(1.0))*uniforms.textureAdditiveColor.a,\\nvec3f(0.0),\\nvec3f(1.0)\\n)+uniforms.textureAdditiveColor.rgb,\\nbaseColor.a\\n);\\n#else\\nbaseColor=textureSample(diffuseSampler,diffuseSamplerSampler,(fragmentInputs.vDiffuseUV+uvOffset));\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"struct lightingInfo\\n{\")}`] = /* wgsl */ \"\\nstruct lightingInfo {\\n#ifdef TOON_TEXTURE\\n#ifndef NDOTL\\nndl: f32,\\n#endif\\nisToon: f32,\\n#endif\\n\";\n            // ndl might be clamped to 1.0\n            codes[`!${escapeRegExp(\"result.diffuse=ndl*diffuseColor*attenuation;\")}`] = /* wgsl */ \"\\n#ifdef TOON_TEXTURE\\nresult.diffuse=diffuseColor*attenuation;result.ndl=ndl;result.isToon=1.0;\\n#elif defined(IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED)\\nresult.diffuse=diffuseColor*attenuation;\\n#else\\nresult.diffuse=(ndl*diffuseColor*attenuation);\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"diffuseBase+=info.diffuse*shadow;\")}`] = /* wgsl */ \"\\n#ifdef TOON_TEXTURE\\ntoonNdl=vec3f(clamp(info.ndl*shadow,0.02,0.98));toonNdl.r=textureSample(toonSampler,toonSamplerSampler,vec2f(0.5,toonNdl.r)).r;toonNdl.g=textureSample(toonSampler,toonSamplerSampler,vec2f(0.5,toonNdl.g)).g;toonNdl.b=textureSample(toonSampler,toonSamplerSampler,vec2f(0.5,toonNdl.b)).b;\\n#ifdef TOON_TEXTURE_COLOR\\ntoonNdl=mix(\\nvec3f(1.0),\\ntoonNdl*uniforms.toonTextureMultiplicativeColor.rgb,\\nuniforms.toonTextureMultiplicativeColor.a\\n);toonNdl=clamp(\\ntoonNdl+(toonNdl-vec3f(1.0))*uniforms.toonTextureAdditiveColor.a,\\nvec3f(0.0),\\nvec3f(1.0)\\n)+uniforms.toonTextureAdditiveColor.rgb;\\n#endif\\ndiffuseBase+=mix(info.diffuse*shadow,toonNdl*info.diffuse,info.isToon);\\n#elif defined(IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED)\\ndiffuseBase+=info.diffuse;\\n#else\\ndiffuseBase+=(info.diffuse*shadow);\\n#endif\\n\";\n            const finalDiffuse = /* wgsl */ \"\\n#ifdef EMISSIVEASILLUMINATION\\nvar finalDiffuse: vec3f=clamp(diffuseBase*diffuseColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\\n#else\\n#ifdef LINKEMISSIVEWITHDIFFUSE\\nvar finalDiffuse: vec3f=clamp((diffuseBase+emissiveColor)*diffuseColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\\n#else\\nvar finalDiffuse: vec3f=clamp(diffuseBase*diffuseColor+emissiveColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\\n#endif\\n#endif\\n\";\n            codes[`!${escapeRegExp(finalDiffuse)}`] = /* wgsl */ `\\n#ifdef APPLY_AMBIENT_COLOR_TO_DIFFUSE\\n#ifdef EMISSIVEASILLUMINATION\\nvar finalDiffuse: vec3f=clamp(diffuseBase*diffuseColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\\n#else\\n#ifdef LINKEMISSIVEWITHDIFFUSE\\nvar finalDiffuse: vec3f=clamp((diffuseBase+emissiveColor)*diffuseColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\\n#else\\nvar finalDiffuse: vec3f=clamp(diffuseBase*diffuseColor+emissiveColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\\n#endif\\n#endif\\n#else\\n${finalDiffuse.replace(\"diffuseBase\", \"(diffuseBase)\")}#endif\\n`;\n            codes[\"CUSTOM_FRAGMENT_BEFORE_FOG\"] = /* wgsl */ \"\\n#if defined(NORMAL) && defined(SPHERE_TEXTURE)\\nvar viewSpaceNormal: vec3f=normalize(mat3x3f(scene.view[0].xyz,scene.view[1].xyz,scene.view[2].xyz)*fragmentInputs.vNormalW);var sphereUV: vec2f=viewSpaceNormal.xy*0.5+0.5;var sphereReflectionColor: vec4f=textureSample(sphereSampler,sphereSamplerSampler,sphereUV);\\n#ifdef SPHERE_TEXTURE_COLOR\\nsphereReflectionColor=vec4f(\\nmix(\\nvec3f(1.0),\\nsphereReflectionColor.rgb*uniforms.sphereTextureMultiplicativeColor.rgb,\\nuniforms.sphereTextureMultiplicativeColor.a\\n),\\nsphereReflectionColor.a\\n);sphereReflectionColor=vec4f(\\nclamp(\\nsphereReflectionColor.rgb+(sphereReflectionColor.rgb-vec3f(1.0))*uniforms.sphereTextureAdditiveColor.a,\\nvec3f(0.0),\\nvec3f(1.0)\\n)+uniforms.sphereTextureAdditiveColor.rgb,\\nsphereReflectionColor.a\\n);\\n#endif\\nsphereReflectionColor=vec4f(sphereReflectionColor.rgb*diffuseBase,sphereReflectionColor.a);\\n#ifdef SPHERE_TEXTURE_BLEND_MODE_MULTIPLY\\ncolor*=sphereReflectionColor;\\n#elif defined(SPHERE_TEXTURE_BLEND_MODE_ADD)\\ncolor=vec4f(color.rgb+sphereReflectionColor.rgb,color.a);\\n#endif\\n#endif\\n\";\n            return codes;\n        }\n        return null;\n    }\n}\n","/**\n * Escape special characters in a string to be used in a regular expression\n * @param str string to escape\n * @returns escaped string\n */\nexport function escapeRegExp(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n"],"names":["MmdPluginMaterial","MmdPluginMaterialBase","isCompatible","shaderLanguage","ShaderLanguage","WGSL","getCustomCode","shaderType","codes","sdefDeclaration","escapeRegExp","sdefVertex","finalDiffuse","replace","str"],"sourceRoot":""}