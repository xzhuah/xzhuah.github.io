{"version":3,"file":"static/js/316.900bb0f4.chunk.js","mappings":"mSAeA,MAAMA,EAAO,yBACPC,EAAoB,k7D,SAE1BC,EAAYC,iBAAiBH,GAAQC,EAE9B,MAAMG,EAAyB,CAAEJ,OAAMC,S","sources":["../node_modules/babylon-mmd/esm/Loader/ShadersWGSL/mmdOutline.vertex.js"],"sourcesContent":["import \"@babylonjs/core/ShadersWGSL/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthDeclaration\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertex\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimation\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthVertex\";\nimport { ShaderStore } from \"@babylonjs/core/Engines/shaderStore\";\nconst name = \"mmdOutlineVertexShader\";\nconst shader = /* wgsl */ \"\\nattribute position: vec3f;attribute normal: vec3f;\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#include<clipPlaneVertexDeclaration>\\nuniform offset: f32;\\n#include<instancesDeclaration>\\nuniform viewport: vec2f;uniform view: mat3x3f;uniform viewProjection: mat4x4f;\\n#ifdef WORLDPOS_REQUIRED\\nuniform inverseViewProjection: mat4x4f;\\n#endif\\n#ifdef ALPHATEST\\nvarying vUV: vec2f;uniform diffuseMatrix: mat4x4f; \\n#ifdef UV1\\nattribute uv: vec2f;\\n#endif\\n#ifdef UV2\\nattribute uv2: vec2f;\\n#endif\\n#endif\\n#include<logDepthDeclaration>\\n#define CUSTOM_VERTEX_DEFINITIONS\\n@vertex\\nfn main(input: VertexInputs)->FragmentInputs {var positionUpdated: vec3f=vertexInputs.position;var normalUpdated: vec3f=vertexInputs.normal;\\n#ifdef UV1\\nvar uvUpdated: vec2f=vertexInputs.uv;\\n#endif\\n#include<morphTargetsVertexGlobal>\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\nvar viewNormal: vec3f=uniforms.view*(mat3x3(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz)*normalUpdated);var projectedPosition: vec4f=uniforms.viewProjection*finalWorld*vec4f(positionUpdated,1.0);var screenNormal: vec2f=normalize(viewNormal.xy);projectedPosition=vec4f(\\nprojectedPosition.xy+(screenNormal/(uniforms.viewport*0.25/*0.5 */)*uniforms.offset*projectedPosition.w),\\nprojectedPosition.z,\\nprojectedPosition.w\\n);vertexOutputs.position=projectedPosition;\\n#ifdef WORLDPOS_REQUIRED\\nvar worldPos: vec4f=uniforms.inverseViewProjection*projectedPosition;\\n#endif\\n#ifdef ALPHATEST\\n#ifdef UV1\\nvertexOutputs.vUV=(uniforms.diffuseMatrix*vec4f(uvUpdated,1.0,0.0)).xy;\\n#endif\\n#ifdef UV2\\nvertexOutputs.vUV=(uniforms.diffuseMatrix*vec4f(vertexInputs.uv2,1.0,0.0)).xy;\\n#endif\\n#endif\\n#include<clipPlaneVertex>\\n#include<logDepthVertex>\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const mmdOutlineVertexShader = { name, shader };\n"],"names":["name","shader","ShaderStore","ShadersStoreWGSL","mmdOutlineVertexShader"],"sourceRoot":""}