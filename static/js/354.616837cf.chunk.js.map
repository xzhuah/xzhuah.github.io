{"version":3,"file":"static/js/354.616837cf.chunk.js","mappings":"2NAKO,MAAMA,UAA0BC,EAAAA,GAMnCC,YAAAA,CAAaC,GACT,OAAQA,IACCC,EAAAA,EAAeC,IAK5B,CACAC,aAAAA,CAAcC,GACV,GAAmB,WAAfA,EAAyB,CACzB,MAAMC,EAAQ,CAAC,EAGf,OAFAA,EAAiC,0BAAIC,EAAAA,EACrCD,EAAM,KAAIE,EAAAA,EAAAA,GAAa,uCAAoD,KAAKC,EAAAA,0CACzEH,CACX,CACA,GAAmB,aAAfD,EAA2B,CAC3B,MAAMC,EAAQ,CACdA,4BAAkD,6JAClDA,EAAM,KAAIE,EAAAA,EAAAA,GAAa,uJAAoK,6NAC3LF,EAAkC,2BAAe,iDACjDA,EAAM,KAAIE,EAAAA,EAAAA,GAAa,2CAAwD,sKAC/EF,EAAM,KAAIE,EAAAA,EAAAA,GAAa,mCAAgD,mHACvEF,EAAM,KAAIE,EAAAA,EAAAA,GAAa,+DAA4E,waACnGF,EAAM,KAAIE,EAAAA,EAAAA,GAAa,6BAA0C,2GAEjEF,EAAM,KAAIE,EAAAA,EAAAA,GAAa,mDAAgE,yQACvFF,EAAM,KAAIE,EAAAA,EAAAA,GAAa,wCAAqD,ssBAC5E,MAAME,EAA0B,wYAGhC,OAFAJ,EAAM,KAAIE,EAAAA,EAAAA,GAAaE,MAA8B,4YAA4YA,EAAaC,QAAQ,cAAe,2BACreL,EAAkC,2BAAe,myBAC1CA,CACX,CACA,OAAO,IACX,CACAM,WAAAA,CAAYX,GACR,MAAO,IACAY,MAAMD,YAAYX,GACrB,SAAY,6bAEpB,E,iBC7CG,SAASO,EAAaM,GACzB,OAAOA,EAAIH,QAAQ,sBAAuB,OAC9C,C","sources":["../node_modules/babylon-mmd/esm/Loader/Shaders/mmdStandard.js","../node_modules/babylon-mmd/esm/Loader/Util/escapeRegExp.js"],"sourcesContent":["import { ShaderLanguage } from \"@babylonjs/core/Materials/shaderLanguage\";\nimport { MmdPluginMaterial as MmdPluginMaterialBase } from \"../mmdPluginMaterial\";\nimport { escapeRegExp } from \"../Util/escapeRegExp\";\nimport { sdefDeclaration } from \"./sdefDeclaration\";\nimport { sdefVertex } from \"./sdefVertex\";\nexport class MmdPluginMaterial extends MmdPluginMaterialBase {\n    /**\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\n     * @param shaderLanguage The shader language to use.\n     * @returns true if the plugin is compatible with the shader language\n     */\n    isCompatible(shaderLanguage) {\n        switch (shaderLanguage) {\n            case ShaderLanguage.GLSL:\n                return true;\n            default:\n                return false;\n        }\n    }\n    getCustomCode(shaderType) {\n        if (shaderType === \"vertex\") {\n            const codes = {};\n            codes[\"CUSTOM_VERTEX_DEFINITIONS\"] = sdefDeclaration;\n            codes[`!${escapeRegExp(\"finalWorld=finalWorld*influence;\")}`] = /* glsl */ `\\n${sdefVertex}\\nfinalWorld=(finalWorld*influence);\\n`;\n            return codes;\n        }\n        if (shaderType === \"fragment\") {\n            const codes = {};\n            codes[\"CUSTOM_FRAGMENT_DEFINITIONS\"] = /* glsl */ \"\\n#if defined(SPHERE_TEXTURE) && defined(NORMAL)\\nuniform sampler2D sphereSampler;\\n#endif\\n#ifdef TOON_TEXTURE\\nuniform sampler2D toonSampler;\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\\nuniform mat4 view;\\n#endif\")}`] = /* glsl */ \"\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\\nuniform mat4 view;\\n#elif defined(NORMAL) && defined(SPHERE_TEXTURE)\\nuniform mat4 view;\\n#endif\\n\";\n            codes[\"CUSTOM_FRAGMENT_MAIN_BEGIN\"] = /* glsl */ \"\\n#ifdef TOON_TEXTURE\\nvec3 toonNdl;\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"vec3 diffuseColor=vDiffuseColor.rgb;\")}`] = /* glsl */ \"\\n#ifdef APPLY_AMBIENT_COLOR_TO_DIFFUSE\\nvec3 diffuseColor=clamp(vDiffuseColor.rgb+vAmbientColor,0.0,1.0);\\n#else\\nvec3 diffuseColor=(vDiffuseColor.rgb);\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"float alpha=vDiffuseColor.a;\")}`] = /* glsl */ \"\\n#ifdef CLAMP_ALPHA\\nfloat alpha=clamp(vDiffuseColor.a,0.0,1.0);\\n#else\\nfloat alpha=vDiffuseColor.a;\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\")}`] = /* glsl */ \"\\n#if defined(DIFFUSE) && defined(TEXTURE_COLOR)\\nbaseColor=texture2D(diffuseSampler,(vDiffuseUV+uvOffset));baseColor.rgb=mix(\\nvec3(1.0),\\nbaseColor.rgb*textureMultiplicativeColor.rgb,\\ntextureMultiplicativeColor.a\\n);baseColor.rgb=clamp(\\nbaseColor.rgb+(baseColor.rgb-vec3(1.0))*textureAdditiveColor.a,\\n0.0,\\n1.0\\n)+textureAdditiveColor.rgb;\\n#else\\nbaseColor=texture2D(diffuseSampler,(vDiffuseUV+uvOffset));\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"struct lightingInfo\\n{\")}`] = /* glsl */ \"\\nstruct lightingInfo {\\n#ifdef TOON_TEXTURE\\n#ifndef NDOTL\\nfloat ndl;\\n#endif\\nfloat isToon;\\n#endif\\n\";\n            // ndl might be clamped to 1.0\n            codes[`!${escapeRegExp(\"result.diffuse=ndl*diffuseColor*attenuation;\")}`] = /* glsl */ \"\\n#ifdef TOON_TEXTURE\\nresult.diffuse=diffuseColor*attenuation;result.ndl=ndl;result.isToon=1.0;\\n#elif defined(IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED) \\nresult.diffuse=diffuseColor*attenuation;\\n#else\\nresult.diffuse=(ndl*diffuseColor*attenuation);\\n#endif\\n\";\n            codes[`!${escapeRegExp(\"diffuseBase+=info.diffuse*shadow;\")}`] = /* glsl */ \"\\n#ifdef TOON_TEXTURE\\ntoonNdl=vec3(clamp(info.ndl*shadow,0.02,0.98));toonNdl.r=texture2D(toonSampler,vec2(0.5,toonNdl.r)).r;toonNdl.g=texture2D(toonSampler,vec2(0.5,toonNdl.g)).g;toonNdl.b=texture2D(toonSampler,vec2(0.5,toonNdl.b)).b;\\n#ifdef TOON_TEXTURE_COLOR\\ntoonNdl=mix(\\nvec3(1.0),\\ntoonNdl*toonTextureMultiplicativeColor.rgb,\\ntoonTextureMultiplicativeColor.a\\n);toonNdl=clamp(\\ntoonNdl+(toonNdl-vec3(1.0))*toonTextureAdditiveColor.a,\\n0.0,\\n1.0\\n)+toonTextureAdditiveColor.rgb;\\n#endif\\ndiffuseBase+=mix(info.diffuse*shadow,toonNdl*info.diffuse,info.isToon);\\n#elif defined(IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED)\\ndiffuseBase+=info.diffuse;\\n#else\\ndiffuseBase+=(info.diffuse*shadow);\\n#endif\\n\";\n            const finalDiffuse = /* glsl */ \"\\n#ifdef EMISSIVEASILLUMINATION\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\n#ifdef LINKEMISSIVEWITHDIFFUSE\\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#endif\\n#endif\\n\";\n            codes[`!${escapeRegExp(finalDiffuse)}`] = /* glsl */ `\\n#ifdef APPLY_AMBIENT_COLOR_TO_DIFFUSE\\n#ifdef EMISSIVEASILLUMINATION\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\\n#else\\n#ifdef LINKEMISSIVEWITHDIFFUSE\\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor,0.0,1.0)*baseColor.rgb;\\n#else\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor,0.0,1.0)*baseColor.rgb;\\n#endif\\n#endif\\n#else\\n${finalDiffuse.replace(\"diffuseBase\", \"(diffuseBase)\")}#endif\\n`;\n            codes[\"CUSTOM_FRAGMENT_BEFORE_FOG\"] = /* glsl */ \"\\n#if defined(NORMAL) && defined(SPHERE_TEXTURE)\\nvec3 viewSpaceNormal=normalize(mat3(view)*vNormalW);vec2 sphereUV=viewSpaceNormal.xy*0.5+0.5;vec4 sphereReflectionColor=texture2D(sphereSampler,sphereUV);\\n#ifdef SPHERE_TEXTURE_COLOR\\nsphereReflectionColor.rgb=mix(\\nvec3(1.0),\\nsphereReflectionColor.rgb*sphereTextureMultiplicativeColor.rgb,\\nsphereTextureMultiplicativeColor.a\\n);sphereReflectionColor.rgb=clamp(\\nsphereReflectionColor.rgb+(sphereReflectionColor.rgb-vec3(1.0))*sphereTextureAdditiveColor.a,\\n0.0,\\n1.0\\n)+sphereTextureAdditiveColor.rgb;\\n#endif\\nsphereReflectionColor.rgb*=diffuseBase;\\n#ifdef SPHERE_TEXTURE_BLEND_MODE_MULTIPLY\\ncolor*=sphereReflectionColor;\\n#elif defined(SPHERE_TEXTURE_BLEND_MODE_ADD)\\ncolor=vec4(color.rgb+sphereReflectionColor.rgb,color.a);\\n#endif\\n#endif\\n\";\n            return codes;\n        }\n        return null;\n    }\n    getUniforms(shaderLanguage) {\n        return {\n            ...super.getUniforms(shaderLanguage),\n            \"fragment\": \"\\n#if defined(DIFFUSE) && defined(TEXTURE_COLOR)\\nuniform vec4 textureMultiplicativeColor;uniform vec4 textureAdditiveColor;\\n#endif\\n#if defined(SPHERE_TEXTURE) && defined(SPHERE_TEXTURE_COLOR)\\nuniform vec4 sphereTextureMultiplicativeColor;uniform vec4 sphereTextureAdditiveColor;\\n#endif\\n#if defined(TOON_TEXTURE) && defined(TOON_TEXTURE_COLOR)\\nuniform vec4 toonTextureMultiplicativeColor;uniform vec4 toonTextureAdditiveColor;\\n#endif\\n\"\n        };\n    }\n}\n","/**\n * Escape special characters in a string to be used in a regular expression\n * @param str string to escape\n * @returns escaped string\n */\nexport function escapeRegExp(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n"],"names":["MmdPluginMaterial","MmdPluginMaterialBase","isCompatible","shaderLanguage","ShaderLanguage","GLSL","getCustomCode","shaderType","codes","sdefDeclaration","escapeRegExp","sdefVertex","finalDiffuse","replace","getUniforms","super","str"],"sourceRoot":""}